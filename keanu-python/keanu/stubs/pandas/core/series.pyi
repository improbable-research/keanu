# Stubs for pandas.core.series (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from pandas.core import base, generic
from typing import Any, Optional

class Series(base.IndexOpsMixin, generic.NDFrame):
    hasnans: Any = ...
    name: Any = ...
    def __init__(self, data: Optional[Any] = ..., index: Optional[Any] = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ...) -> None: ...
    @classmethod
    def from_array(cls, arr: Any, index: Optional[Any] = ..., name: Optional[Any] = ..., dtype: Optional[Any] = ..., copy: bool = ..., fastpath: bool = ...): ...
    @property
    def name(self): ...
    @name.setter
    def name(self, value: Any) -> None: ...
    @property
    def dtype(self): ...
    @property
    def dtypes(self): ...
    @property
    def ftype(self): ...
    @property
    def ftypes(self): ...
    @property
    def values(self): ...
    def get_values(self): ...
    @property
    def asobject(self): ...
    def ravel(self, order: str = ...): ...
    def compress(self, condition: Any, *args: Any, **kwargs: Any): ...
    def nonzero(self): ...
    def put(self, *args: Any, **kwargs: Any) -> None: ...
    def __len__(self): ...
    def view(self, dtype: Optional[Any] = ...): ...
    def __array__(self, result: Optional[Any] = ...): ...
    def __array_wrap__(self, result: Any, context: Optional[Any] = ...): ...
    def __array_prepare__(self, result: Any, context: Optional[Any] = ...): ...
    @property
    def real(self): ...
    @real.setter
    def real(self, v: Any) -> None: ...
    @property
    def imag(self): ...
    @imag.setter
    def imag(self, v: Any) -> None: ...
    __float__: Any = ...
    __long__: Any = ...
    __int__: Any = ...
    @property
    def axes(self): ...
    def __getitem__(self, key: Any): ...
    def __setitem__(self, key: Any, value: Any): ...
    def repeat(self, repeats: Any, *args: Any, **kwargs: Any): ...
    def get_value(self, label: Any, takeable: bool = ...): ...
    def set_value(self, label: Any, value: Any, takeable: bool = ...): ...
    index: Any = ...
    def reset_index(self, level: Optional[Any] = ..., drop: bool = ..., name: Optional[Any] = ..., inplace: bool = ...): ...
    def __unicode__(self): ...
    def to_string(self, buf: Optional[Any] = ..., na_rep: str = ..., float_format: Optional[Any] = ..., header: bool = ..., index: bool = ..., length: bool = ..., dtype: bool = ..., name: bool = ..., max_rows: Optional[Any] = ...): ...
    def iteritems(self): ...
    items: Any = ...
    def keys(self): ...
    def to_dict(self, into: Any = ...): ...
    def to_frame(self, name: Optional[Any] = ...): ...
    def to_sparse(self, kind: str = ..., fill_value: Optional[Any] = ...): ...
    def count(self, level: Optional[Any] = ...): ...
    def mode(self, dropna: bool = ...): ...
    def unique(self): ...
    def drop_duplicates(self, keep: str = ..., inplace: bool = ...): ...
    def duplicated(self, keep: str = ...): ...
    def idxmin(self, axis: int = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    def idxmax(self, axis: int = ..., skipna: bool = ..., *args: Any, **kwargs: Any): ...
    argmin: Any = ...
    argmax: Any = ...
    def round(self, decimals: int = ..., *args: Any, **kwargs: Any): ...
    def quantile(self, q: float = ..., interpolation: str = ...): ...
    def corr(self, other: Any, method: str = ..., min_periods: Optional[Any] = ...): ...
    def cov(self, other: Any, min_periods: Optional[Any] = ...): ...
    def diff(self, periods: int = ...): ...
    def autocorr(self, lag: int = ...): ...
    def dot(self, other: Any): ...
    def __matmul__(self, other: Any): ...
    def __rmatmul__(self, other: Any): ...
    def searchsorted(self, value: Any, side: str = ..., sorter: Optional[Any] = ...): ...
    def append(self, to_append: Any, ignore_index: bool = ..., verify_integrity: bool = ...): ...
    def combine(self, other: Any, func: Any, fill_value: Optional[Any] = ...): ...
    def combine_first(self, other: Any): ...
    def update(self, other: Any) -> None: ...
    def sort_values(self, by: Optional[Any] = ..., axis: int = ..., ascending: Any = ..., inplace: Any = ..., kind: str = ..., na_position: str = ...) -> None: ...
    def sort_index(self, axis: int = ..., level: Optional[Any] = ..., ascending: bool = ..., inplace: bool = ..., kind: str = ..., na_position: str = ..., sort_remaining: bool = ...): ...
    def argsort(self, axis: int = ..., kind: str = ..., order: Optional[Any] = ...): ...
    def nlargest(self, n: int = ..., keep: str = ...): ...
    def nsmallest(self, n: int = ..., keep: str = ...): ...
    def swaplevel(self, i: int = ..., j: int = ..., copy: Any = ...): ...
    def reorder_levels(self, order: Any): ...
    def unstack(self, level: int = ..., fill_value: Optional[Any] = ...): ...
    def map(self, arg: Any, na_action: Optional[Any] = ...): ...
    def aggregate(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    agg: Any = ...
    def transform(self, func: Any, axis: int = ..., *args: Any, **kwargs: Any): ...
    def apply(self, func: Any, convert_dtype: bool = ..., args: Any = ..., **kwds: Any): ...
    def align(self, other: Any, join: str = ..., axis: Optional[Any] = ..., level: Optional[Any] = ..., copy: bool = ..., fill_value: Optional[Any] = ..., method: Optional[Any] = ..., limit: Optional[Any] = ..., fill_axis: int = ..., broadcast_axis: Optional[Any] = ...): ...
    def rename(self, *args: Any, **kwargs: Any): ...
    def reindex(self, *args: Any, **kwargs: Any): ...
    def drop(self, labels: Optional[Any] = ..., axis: int = ..., index: Optional[Any] = ..., columns: Optional[Any] = ..., level: Optional[Any] = ..., inplace: bool = ..., errors: str = ...): ...
    def fillna(self, value: Optional[Any] = ..., method: Optional[Any] = ..., axis: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., downcast: Optional[Any] = ..., **kwargs: Any): ...
    def replace(self, to_replace: Optional[Any] = ..., value: Optional[Any] = ..., inplace: bool = ..., limit: Optional[Any] = ..., regex: bool = ..., method: str = ...): ...
    def shift(self, periods: int = ..., freq: Optional[Any] = ..., axis: int = ...): ...
    def reindex_axis(self, labels: Any, axis: int = ..., method: Optional[Any] = ..., level: Optional[Any] = ..., copy: Any = ..., limit: Optional[Any] = ..., fill_value: Optional[Any] = ...): ...
    def memory_usage(self, deep: bool = ...): ...
    def isin(self, values: Any): ...
    def between(self, left: Any, right: Any, inclusive: bool = ...): ...
    @classmethod
    def from_csv(cls, path: Any, sep: str = ..., parse_dates: bool = ..., header: Optional[Any] = ..., index_col: int = ..., encoding: Optional[Any] = ..., infer_datetime_format: bool = ...): ...
    def to_csv(self, *args: Any, **kwargs: Any): ...
    def to_excel(self, excel_writer: Any, sheet_name: str = ..., na_rep: str = ..., float_format: Optional[Any] = ..., columns: Optional[Any] = ..., header: bool = ..., index: bool = ..., index_label: Optional[Any] = ..., startrow: int = ..., startcol: int = ..., engine: Optional[Any] = ..., merge_cells: bool = ..., encoding: Optional[Any] = ..., inf_rep: str = ..., verbose: bool = ...) -> None: ...
    def isna(self): ...
    def isnull(self): ...
    def notna(self): ...
    def notnull(self): ...
    def dropna(self, axis: int = ..., inplace: bool = ..., **kwargs: Any): ...
    def valid(self, inplace: bool = ..., **kwargs: Any): ...
    def to_timestamp(self, freq: Optional[Any] = ..., how: str = ..., copy: bool = ...): ...
    def to_period(self, freq: Optional[Any] = ..., copy: bool = ...): ...
    str: Any = ...
    dt: Any = ...
    cat: Any = ...
    plot: Any = ...
    sparse: Any = ...
    hist: Any = ...
